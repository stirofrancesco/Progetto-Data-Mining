#Lettura dataset di espressione
expressiondf <- read.delim("expression_data.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Caricamento nodi METAPATHWAY
nodes<- read.delim("nodes.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Caricamento archi METAPATHWAY
edges<- read.delim("edges.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Traspongo il dataset di espressione affinchè i pazienti siano le osservazioni.
{
expression <- transpose(expressiondf)
rownames(expression) <- colnames(expressiondf)
colnames(expression) <- rownames(expressiondf)
rm(expressiondf)
}
library(igraph)
library(DNetFinder)
library(stringi)
library(data.table)
#Lettura dataset di espressione
expressiondf <- read.delim("expression_data.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
setwd("C:/Users/stiro/OneDrive/Documenti/GitHub/Progetto-Data-Mining/dati progetto")
#Lettura dataset di espressione
expressiondf <- read.delim("expression_data.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Caricamento nodi METAPATHWAY
nodes<- read.delim("nodes.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Caricamento archi METAPATHWAY
edges<- read.delim("edges.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Traspongo il dataset di espressione affinchè i pazienti siano le osservazioni.
{
expression <- transpose(expressiondf)
rownames(expression) <- colnames(expressiondf)
colnames(expression) <- rownames(expressiondf)
rm(expressiondf)
}
#Tengo solamente Attivazione e Inibizione e assegno i pesi negli archi della METAPATHWAY.
{
edges$Type <- NULL
edges <- edges[!(edges$Subtype!="ACTIVATION" & edges$Subtype!="INHIBITION"),]
edges$Subtype[edges$Subtype=="ACTIVATION"] <- "1"
edges$Subtype[edges$Subtype=="INHIBITION"] <- "-1"
edges$Subtype = as.numeric(as.character(edges$Subtype))
colnames(edges)[3] <- "weight"
}
#Considero solo i geni presenti in tutti i dataset.
{
v1 <- colnames(expression)
v2 <- unique(c(edges$X.Start,edges$End))
v3 <- nodes$X.Id
common <- c()
for(i in 1:length(v1)){
if(v1[i] %in% v3) common <- c(common,v1[i])
}
expression <- expression[,common]
edges <- edges[(edges$X.Start %in% common) & (edges$End %in% common),]
nodes <- nodes[nodes$X.Id %in% common,]
v1 <- colnames(expression)
v2<- unique(c(edges$X.Start,edges$End))
v3 <- nodes$X.Id
common <- c()
for(i in 1:length(v1)){
if(v1[i] %in% v2 && v1[i] %in% v3) common <- c(common,v1[i])
}
expression <- expression[,common]
nodes <- nodes[nodes$X.Id %in% common,]
rm(v1,v2,v3,i,common,numcol,numrow)
}
#Creazione grafo METAPATHWAY
metapathway <- graph_from_data_frame(edges,
directed=TRUE)
#Creazione matrice di adiacenza METAPATHWAY
adj_metapathway <- as.matrix(as_adjacency_matrix(metapathway))
#Lettura dataset di espressione
expressiondf <- read.delim("expression_data.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Caricamento nodi METAPATHWAY
nodes<- read.delim("nodes.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Caricamento archi METAPATHWAY
edges<- read.delim("edges.txt",
header = TRUE,
sep = "\t",
colClasses = "character")
#Traspongo il dataset di espressione affinchè i pazienti siano le osservazioni.
{
expression <- transpose(expressiondf)
rownames(expression) <- colnames(expressiondf)
colnames(expression) <- rownames(expressiondf)
rm(expressiondf)
}
#Tengo solamente Attivazione e Inibizione e assegno i pesi negli archi della METAPATHWAY.
{
edges$Type <- NULL
edges <- edges[!(edges$Subtype!="ACTIVATION" & edges$Subtype!="INHIBITION"),]
edges$Subtype[edges$Subtype=="ACTIVATION"] <- "1"
edges$Subtype[edges$Subtype=="INHIBITION"] <- "-1"
edges$Subtype = as.numeric(as.character(edges$Subtype))
colnames(edges)[3] <- "weight"
}
#Considero solo i geni presenti in tutti i dataset.
{
v1 <- colnames(expression)
v2 <- unique(c(edges$X.Start,edges$End))
v3 <- nodes$X.Id
common <- c()
for(i in 1:length(v1)){
if(v1[i] %in% v3) common <- c(common,v1[i])
}
expression <- expression[,common]
edges <- edges[(edges$X.Start %in% common) & (edges$End %in% common),]
nodes <- nodes[nodes$X.Id %in% common,]
v1 <- colnames(expression)
v2<- unique(c(edges$X.Start,edges$End))
v3 <- nodes$X.Id
common <- c()
for(i in 1:length(v1)){
if(v1[i] %in% v2 && v1[i] %in% v3) common <- c(common,v1[i])
}
expression <- expression[,common]
nodes <- nodes[nodes$X.Id %in% common,]
rm(v1,v2,v3,i,common,numcol,numrow)
}
